C++ Reactor WebServer
-
一、使用Reactor模型
-
Reactor处理模式，包括主线程和工作线程两部分

主线程：使用epoll作为IO多路复用的实现方式，主线程只负责监听文件描述符上是否有时间发生，有的话将对应的文件描述符交给工作线程去处理

工作线程：在程序开始时便创建固定数量的线程池

Reactor的工作流程一般如下：
- 1，主线程往epoll内核事件表中注册socket上的读就绪事件
- 2，主线程调用epoll_wait等待socket上有数据可读
- 3，当socket上有数据可读时，epoll_wait通知主线程，主线程就将可读事件放入请求队列
- 4，睡眠在请求队列上某个工作线程被唤醒，它从socket读取数据，并处理客户请求，然后往epoll内核事件表中注册socket上的写就绪事件
- 5，主线程调用epoll_wait等待socket可写
- 6，当socket可写，epoll_wait通知主线程，主线程则将可写事件放入请求队列
- 7，睡眠在请求队列上某个工作线程被唤醒 ，它往socket上写入服务器处理客户请求的结果

二、使用epoll+非阻塞IO+边缘触发(ET)实现高并发处理请求
-
- 区别电平触发(LT)和边沿触发(ET):
 LT:当epoll_wait检测到socket上有事件发生并将此事件通知应用程序之后，应用程序可以不用立即处理该事件。当下一次调用epoll_wait时，还会再次向应用程序告知事件，直到该事件被处理
 ET：当epoll_wait检测到socket上有事件发生并将此事件通知到应用程序之后，应用程序必须立即处理该事件

∴ 用ET模式在很大程序上降低了同一个epoll事件被重复触发的次数，因此效率要比LT模式高

- epoll使用EPOLLONESHOT保证一个socket连接在任意时刻都只被一个线程处理

针对使用ET模式还是可能被触发多次，只有在epoll_ctl函数的文件描述符上注册EPOLLONESHOT事件，此时只触发一次，从而保证一个socket连接在任意时刻只被一个线程处理

三、使用多线程充分利用多核CPU，并使用线程池避免频繁创建销毁线程的开销
-

创建一个线程池，线程池中主要包含任务队列和工作线程，使用了一个固定线程数的工作线程

工作线程之间对任务队列的竞争采用条件变量和互斥锁结合使用

一个工作线程先加互斥锁，当任务队列中任务数量为0时，阻塞在条件变量

当任务队列大于0时，用条件变量通知阻塞在条件变量下的线程，这些线程来继续竞争获取获取任务

对任务队列中任务的调度采用先来先服务的算法


四、状态机解析HTTP请求
-

在主线程循环监听到读写套接字有报文传过来以后 在工作线程调用requestData中的handleRequest进行使用状态机解析了HTTP请求

1）这里支持两种类型GET和POST

根据http请求报文的请求行去判断是请求类型字符串是"GET"还是"POST"

然后用一个map存放首部行的键值对数据

如果是post报文的话 首部行里面必然会有Content-length字段而get没有 所以取出这个字段 求出后面实体主体时候要取用的长度 

然后往下走回送相应的http响应报文即可

而get报文 实体主体是空的 直接读取请求行的url数据 然后往下走回送相应的http响应报文即可

(2)在这是支持长连接 keep-alive

在首部行读取出来数据以后如果请求方设置了长连接 则Connection字段为keep-alive以此作为依据

如果读取到这个字段的话就在报文解析 报文回送完毕之后将requestData重置 

然后将该套接字属性也用epoll_ctl重置 再次加入epoll监听



五、使用priority队列实现的最小堆结构管理定时器，使用标记删除
-

定时器结点的添加和删除，需要加锁，主线程和工作线程都要操作定时器队列
